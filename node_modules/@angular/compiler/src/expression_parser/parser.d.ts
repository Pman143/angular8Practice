/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import {InterpolationConfig} from '../ml_parser/interpolation_config';
import {AST, ASTWithSource, BindingPipe, LiteralMap, ParserError, ParseSpan, TemplateBinding} from './ast';
import {Lexer, Token} from './lexer';

export declare class SplitInterpolation {
  strings: string[];
  expressions: string[];
  offsets: number[];

  constructor(strings: string[], expressions: string[], offsets: number[]);
}

export declare class TemplateBindingParseResult {
  templateBindings: TemplateBinding[];
  warnings: string[];
  errors: ParserError[];

  constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);
}

export declare class Parser {
  private _lexer;
  private errors;
  private _reportError;
  private _parseBindingAst;
  private _parseQuote;
  private _stripComments;
  private _commentStart;
  private _checkNoInterpolation;
  private _findInterpolationErrorColumn;

  constructor(_lexer: Lexer);

  parseAction(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;

  parseBinding(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;

  parseSimpleBinding(input: string, location: string, interpolationConfig?: InterpolationConfig): ASTWithSource;

  parseTemplateBindings(tplKey: string, tplValue: string, location: any): TemplateBindingParseResult;

  parseInterpolation(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource | null;

  splitInterpolation(input: string, location: string, interpolationConfig?: InterpolationConfig): SplitInterpolation | null;

  wrapLiteralPrimitive(input: string | null, location: any): ASTWithSource;
}

export declare class _ParseAST {
  input: string;
  location: any;
  tokens: Token[];
  inputLength: number;
  parseAction: boolean;
  index: number;
  readonly next: Token;
  readonly inputIndex: number;
  private errors;
  private offset;
  private rparensExpected;
  private rbracketsExpected;
  private rbracesExpected;
  private locationText;
  private skip;

  constructor(input: string, location: any, tokens: Token[], inputLength: number, parseAction: boolean, errors: ParserError[], offset: number);

  peek(offset: number): Token;

  span(start: number): ParseSpan;

  advance(): void;

  optionalCharacter(code: number): boolean;

  peekKeywordLet(): boolean;

  peekKeywordAs(): boolean;

  expectCharacter(code: number): void;

  optionalOperator(op: string): boolean;

  expectOperator(operator: string): void;

  expectIdentifierOrKeyword(): string;

  expectIdentifierOrKeywordOrString(): string;

  parseChain(): AST;

  parsePipe(): AST;

  parseExpression(): AST;

  parseConditional(): AST;

  parseLogicalOr(): AST;

  parseLogicalAnd(): AST;

  parseEquality(): AST;

  parseRelational(): AST;

  parseAdditive(): AST;

  parseMultiplicative(): AST;

  parsePrefix(): AST;

  parseCallChain(): AST;

  parsePrimary(): AST;

  parseExpressionList(terminator: number): AST[];

  parseLiteralMap(): LiteralMap;

  parseAccessMemberOrMethodCall(receiver: AST, isSafe?: boolean): AST;

  parseCallArguments(): BindingPipe[];

  /**
   * An identifier, a keyword, a string with an optional `-` in between.
   */
  expectTemplateBindingKey(): string;

  parseTemplateBindings(tplKey: string): TemplateBindingParseResult;

  error(message: string, index?: number | null): void;
}
